#### 信号
- 信号是由用户，系统或者进程发送给目标进程的信息，以通知目标进程某个状态的改变或系统异常
- 简而言之，信号是一种软件中断，提供了一种处理异步的方法，信号的发生是随机的
#### 信号的来源
- Linux 信号可由如下条件产生
  - 对于前台进程，用户可以通过输入特殊的终端字符来给它发送信号。比如输入 Ctrl + C 通常会给进程发送一个中断信号
  - 系统异常。比如浮点异常和非法内存段访问
  - 系统状态变化。比如alram定时器到期将引起SIGALRM信号
  - 运行kill命令或调用kill函数

#### 信号种类
- 信号分为可靠信号与不可靠信号。可靠信号又称为实时信号，非可靠信号又称为非实时信号
- 信号代码从 1 - 32是不可靠信号，不可靠信号主要有以下问题
  - 每次信号处理完之后，就会恢复成默认处理，这可能是调用者不希望看到的
  - 存在信号丢失问题
    - 现在的Linux 对信号机制进行了改进，因此，不可靠信号主要是指信号丢失
- 信号代码从 SIGRTMIN 到 SIGRTMAX之间的信号是可靠信号
  - 可靠信号不存在丢失，由sigueue发送，可靠信号支持排队
- 可靠信号注册机制
  - 内核每收到一个可靠信号都会去注册这个信号，在信号的未决信号链中分配sigqueue 结构，因此，不会存在信号丢失的问题
- 不可靠信号注册机制
  - 而对于不可靠的信号，如果内核已经注册了这个信号，那么便不会再去注册，对于进程来讲，便不会知道本次信号的产生
- 可靠信号与不可靠信号与发送函数没有关系，而是取决于信号代码，前面的32种信号就是不可靠信号，而后面的32种信号就是可靠信号

#### 信号处理函数过程
- 注册信号处理函数
  - 信号的处理是有内核代理的，首先程序通过sigal 或 sigaction函数为每个信号注册处理函数
  - 而内核中维护一张信号向量表，对应信号处理机制
  - 这样，信号在进程中注销完毕之后，会调用相应处理函数进行处理
- 信号的检测和响应时机
  - 在系统调用或中断返回用户态的前夕，内核会检查未决信号集，进行相应的信号处理
- 处理过程
  - 过程
    - 程序运行在用户态时
    -  -> 进程由于系统调用或中断进入内核
    -  -> 转向用户态执行信号处理函数
    -  -> 信号处理函数完毕后进入内核
    -  -> 返回用户态继续执行程序
  - 首先程序执行在用户态，在进程陷入并从内核返回的前夕，会去检查有没有信号没有被处理
  - 如果有且没有被阻塞就会调用相应的信号处理函数程序去处理
  - 首先，内核在用户栈上创建一个层，该层中将返回地址设置成信号处理函数的地址
  - 这样，从内核返回用户态时，就会执行这个信号处理函数
  - 当信号处理函数执行完，会再次进入内核，主要是检测有没有信号没有处理，以及恢复原先程序中断执行点，恢复内核等工作，这样，当从内核返回后到原先程序执行的地方
#### 信号表
|序号 | 信号名 | 信号解释 | 默认处理|
| ----- | ---- | ---- |---- |
|1) | SIGHUP | 连接挂断 | 终止(默认处理) |
|2) | SIGINT| 终端中断,Ctrl+c产生该信号 | 终止(terminate) |
|3) | SIGQUIT| 终端退出,Ctrl+\ | 终止+转储|
|6) | SIGABRT| 进程异常终止,abort()产生 | 终止+转储|
|9) | SIGKILL| 不可以被捕获或忽略的终止信号 | 终止|
|10) | SIGUSR1| 用户定义信号1 | 终止(terminate) |
|11) | SIGSEGV| 无效的内存段访问=>Segmentation error | 终止+转储|
|12) | SIGUSR2| 用户定义信号2 | 终止|
|13) | SIGPIPE| 向读端已关闭的管道写入 | 终止|
|14) | SIGALRM| 真实定时器到期,alarm()产生 | 终止|
|15) | SIGTERM| 可以被捕获或忽略的终止信号 | 终止|
|17) | SIGCHLD| 子进程已经停止, 对于管理子进程很有用 | 忽略|
|19) | SIGSTOP| 不能被捕获或忽略的停止信号 | 停止(stop)|
