#### 信号处理函数过程
- 注册信号处理函数
  - 信号的处理是有内核代理的，首先程序通过sigal 或 sigaction函数为每个信号注册处理函数
  - 而内核中维护一张信号向量表，对应信号处理机制
  - 这样，信号在进程中注销完毕之后，会调用相应处理函数进行处理
- 信号的检测和响应时机
  - 在系统调用或中断返回用户态的前夕，内核会检查未决信号集，进行相应的信号处理
- 处理过程
  - 过程
    - 程序运行在用户态时
    -  -> 进程由于系统调用或中断进入内核
    -  -> 转向用户态执行信号处理函数
    -  -> 信号处理函数完毕后进入内核
    -  -> 返回用户态继续执行程序
  - 首先程序执行在用户态，在进程陷入并从内核返回的前夕，会去检查有没有信号没有被处理
  - 如果有且没有被阻塞就会调用相应的信号处理函数程序去处理
  - 首先，内核在用户栈上创建一个层，该层中将返回地址设置成信号处理函数的地址
  - 这样，从内核返回用户态时，就会执行这个信号处理函数
  - 当信号处理函数执行完，会再次进入内核，主要是检测有没有信号没有处理，以及恢复原先程序中断执行点，恢复内核等工作，这样，当从内核返回后到原先程序执行的地方
#### 信号表
|序号 | 信号名 | 信号解释 | 默认处理|
| ----- | ---- | ---- |---- |
|1) | SIGHUP | 连接挂断 | 终止(默认处理) |
|2) | SIGINT| 终端中断,Ctrl+c产生该信号 | 终止(terminate) |
|3) | SIGQUIT| 终端退出,Ctrl+\ | 终止+转储|
|6) | SIGABRT| 进程异常终止,abort()产生 | 终止+转储|
|9) | SIGKILL| 不可以被捕获或忽略的终止信号 | 终止|
|10) | SIGUSR1| 用户定义信号1 | 终止(terminate) |
|11) | SIGSEGV| 无效的内存段访问=>Segmentation error | 终止+转储|
|12) | SIGUSR2| 用户定义信号2 | 终止|
|13) | SIGPIPE| 向读端已关闭的管道写入 | 终止|
|14) | SIGALRM| 真实定时器到期,alarm()产生 | 终止|
|15) | SIGTERM| 可以被捕获或忽略的终止信号 | 终止|
|17) | SIGCHLD| 子进程已经停止, 对于管理子进程很有用 | 忽略|
|19) | SIGSTOP| 不能被捕获或忽略的停止信号 | 停止(stop)|
